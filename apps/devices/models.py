# -*- coding: utf-8 -*-
from __future__ import unicode_literals
import uuid

from django.db import models

from .constants import (
    TYPE_OTHER, DEVICE_TYPE_CHOICES,
    STATUS_INITIAL, STATUS_OK, DEVICE_STATUS_CHOICES,
    QUERY_SYNC, QUERY_SYNC_PARTIAL, QUERY_ACTION
)

from django_module_attr.models import GenericData, Attribute

from apps.locations.models import Location
from apps.manufacters.models import Manufacter
from apss.components.models_md import EventAction

#
# https://developers.google.com/assistant/smarthome/guides
# https://developers.google.com/assistant/smarthome/concepts/homegraph
# https://developers.google.com/assistant/smarthome/concepts/devices-traits
#


class Device(models.Model):
    device_uuid = models.UUIDField(default=uuid.uuid4, unique=True)
    external_id = models.CharField(max_length=100)
    name = models.CharField(max_length=100, blank=True, default='')
    type = models.CharField(max_length=10,
                            default=TYPE_OTHER,
                            choices=DEVICE_TYPE_CHOICES)
    # class_device ---> Este podria indicar algun tipo de comportamiento
    status = models.CharField(max_length=10,
                              default=STATUS_INITIAL,
                              choices=DEVICE_STATUS_CHOICES)
    enabled = models.BooleanField(default=True)

    # Generated by the system
    # Store specific data and state, can group all the components's state
    # Every device store your own metadata
    # Aca retornamos no solo caracteristica y estado si no que tambien que se puede hacer
    # con este device. Es algo que van a usar los front o quien consuma la api para asi saber que
    # puede hacer.
    metadata = models.ForeignKey(GenericData,
                                 null=True,
                                 related_name="+",
                                 on_delete=models.CASCADE)
    # Atributos del dispositivo
    attrs = models.ManyToManyField(Attribute, related_name="+")

    container = models.ForeignKey("Device",
                                  null=True,
                                  related_name="devices",
                                  on_delete=models.PROTECT)
    location = models.ForeignKey(Location,
                                 null=True,
                                 related_name="devices",
                                 on_delete=models.PROTECT)
    manufacter = models.ForeignKey(Manufacter,
                                   null=True,
                                   related_name="devices",
                                   on_delete=models.PROTECT)

    created_at = models.DateTimeField(auto_now_add=True)
    updated_at = models.DateTimeField(auto_now=True)

    class Meta:
        ordering = ('created_at',)

    @classmethod
    def create(cls, external_id, name, location, manufacter, type=TYPE_OTHER, container=None, attrs=[]):
        device = Device.objects.create(
            external_id=external_id,
            name=name,
            type=type,
            location=location,
            manufacter=manufacter,
            container=container
        )
        device.attrs.set(attrs)

        return device

    def execute_sync(self, component=None):
        data = {'type': QUERY_SYNC}
        if component:
            data.append({
                'type': QUERY_SYNC_PARTIAL,
                'trait': component.external_id
            })
        self.manufacter.send(self, data)

    def execute_action(self, component, data, user=None):
        data.append({
            'type': QUERY_ACTION,
            'component': component.external_id,
            # More metadata???
        })
        self.manufacter.send(self, data)

        # Register the event
        EventAction.create(
            self.id,
            component.id,
            component.type,
            data,
            user.id if user else None
        )

    def receive_action(self, data):
        # Not for now
        pass

    def receive_sync(self, data):
        if self.status != STATUS_OK:
            self.status = STATUS_OK
            self.save()

        for trait_data in data.get('traits', []):
            try:
                component = self.components.get(external_id=trait_data.get('external_id', None))
                component.receive_sync(trait_data, False)
            except models.Model.DoesNotExist:
                pass

    def receive_sync_partial(self, data):
        try:
            component = self.components.get(external_id=data.get('external_id', None))
            component.receive_sync(data)
        except models.Model.DoesNotExist:
            pass
