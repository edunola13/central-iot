# -*- coding: utf-8 -*-
from __future__ import unicode_literals
import uuid

from django.db import models, transaction
from django.contrib.auth import get_user_model
from django.core.exceptions import ObjectDoesNotExist

from iot_devices.proto.devices_pb2 import Payload
from iot_devices.proto.wrapper import PayloadWrapper

from .constants import (
    TYPE_OTHER, DEVICE_TYPE_CHOICES,
    STATUS_INITIAL, STATUS_OK, STATUS_DISCONNECT,
    DEVICE_STATUS_CHOICES,
    QUERY_ACTION_TYPE_USER, QUERY_ACTION_TYPE_RULE
)

from django_module_attr.models import GenericData, Attribute

from apps.locations.models import Location
from apps.manufacters.models import Manufacter
from apps.components.models_md import EventAction, EventState

User = get_user_model()


class Device(models.Model):
    """
    Modelo Device.

    https://developers.google.com/assistant/smarthome/guides
    https://developers.google.com/assistant/smarthome/concepts/homegraph
    https://developers.google.com/assistant/smarthome/concepts/devices-traits
    """

    device_uuid = models.UUIDField(default=uuid.uuid4, unique=True)
    external_id = models.CharField(max_length=100)
    name = models.CharField(max_length=100, blank=True, default='')
    type = models.CharField(max_length=10,
                            default=TYPE_OTHER,
                            choices=DEVICE_TYPE_CHOICES)
    # class_device ---> Este podria indicar algun tipo de comportamiento
    status = models.CharField(max_length=10,
                              default=STATUS_INITIAL,
                              choices=DEVICE_STATUS_CHOICES)
    enabled = models.BooleanField(default=True)

    # Generated by the system
    # Store specific data and state
    # Every device store your own metadata
    metadata = models.ForeignKey(GenericData,
                                 null=True,
                                 related_name="+",
                                 on_delete=models.CASCADE)
    # Atributos del dispositivo. THINK DIFERENCE WITH metadata['config']
    attrs = models.ManyToManyField(Attribute, related_name="+")

    container = models.ForeignKey("Device",
                                  null=True,
                                  related_name="devices",
                                  on_delete=models.PROTECT)
    location = models.ForeignKey(Location,
                                 null=True,
                                 related_name="devices",
                                 on_delete=models.PROTECT)
    manufacter = models.ForeignKey(Manufacter,
                                   null=True,
                                   related_name="devices",
                                   on_delete=models.PROTECT)

    created_at = models.DateTimeField(auto_now_add=True)
    updated_at = models.DateTimeField(auto_now=True)

    class Meta:
        ordering = ('created_at',)

    @classmethod
    def create(
        cls, external_id, name, location, manufacter, type=TYPE_OTHER,
        config_metadata=None, container=None, attrs=[],
    ):
        with transaction.atomic():
            metadata = GenericData.create({
                'config': config_metadata,  # Every device store that it need (only cloud)
                'data': {},  # Some state, value general. For example: name, status of alarm
            })

            device = Device.objects.create(
                external_id=external_id,
                name=name,
                type=type,
                location=location,
                manufacter=manufacter,
                container=container,
                metadata=metadata
            )
            device.attrs.set(attrs)

        return device

    def remove(self):
        """Remueve el device con tosos sus componentes y atributos."""
        with transaction.atomic():
            self.components.all().delete()
            self.attrs.all().delete()
            self.delete()

    def register_action(self, payload: PayloadWrapper, user: User=None):
        """Register the event."""
        EventAction.create(
            self.id,
            None,  # No component
            QUERY_ACTION_TYPE_USER if user else QUERY_ACTION_TYPE_RULE,
            payload.to_dict(),
            user.id if user else None
        )

    def receive_sync(self, payload: PayloadWrapper):
        try:
            if self.status != STATUS_OK:
                self.status = STATUS_OK
                self.save(update_fields=['status'])

            metadata = self.metadata.get_value()
            if metadata:  # If None do nothing
                metadata['data'] = {k: v for k, v in payload.device.values.items()}
                self.metadata.update_value(metadata)
                if payload.device.name:
                    self.name = payload.device.name
                    self.save(update_fields=['name'])

            for trait in payload.traits:
                try:
                    component = self.components.get(external_id=trait.id)
                    component.receive_sync(payload, trait, False)
                except ObjectDoesNotExist:
                    pass
        except:
            logging.exception('[SYNC] Fail the sync response.')
            self.status = STATUS_ERROR
            self.save(update_fields=['status'])

    def receive_state(self, payload: PayloadWrapper):
        if payload.device.name:
            self.name = payload.device.name
            self.save(update_fields=['name'])

        if payload.device.values:
            metadata = self.metadata.get_value()
            if metadata:  # If None do nothing
                metadata['data'].update(
                    {k: v for k, v in payload.device.values.items()}
                )
                self.metadata.update_value(metadata)

            if payload.sub_type != Payload.PAYLOAD_SUB_TYPE_NONE:
                # If NONE solicito el cloud, entonces no registrar
                EventState.create(
                    self.pk,
                    None,  # No component
                    payload.sub_type,
                    payload.device.values
                )

        for trait in payload.traits:
            try:
                component = self.components.get(external_id=trait.id)
                component.receive_state(payload, trait)
            except ObjectDoesNotExist:
                pass

    def receive_action(self, payload: PayloadWrapper):
        """Not for now."""
        pass

    def is_ready(self):
        return self.status in [STATUS_OK, STATUS_DISCONNECT]
